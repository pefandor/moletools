---
import Layout from '../../layouts/Layout.astro';
import FAQ from '../../components/FAQ.astro';
import toolsData from '../../data/tools.json';

const tool = toolsData.find(t => t.id === 'watermark')!;

const jsonLd = {
  '@context': 'https://schema.org',
  '@type': 'WebApplication',
  name: tool.name,
  description: tool.description,
  applicationCategory: 'DeveloperApplication',
  operatingSystem: 'Any',
  offers: {
    '@type': 'Offer',
    price: '0',
    priceCurrency: 'USD'
  },
  browserRequirements: 'Requires JavaScript',
  permissions: 'No special permissions required'
};

const faqJsonLd = {
  '@context': 'https://schema.org',
  '@type': 'FAQPage',
  mainEntity: tool.faq.map(item => ({
    '@type': 'Question',
    name: item.question,
    acceptedAnswer: {
      '@type': 'Answer',
      text: item.answer
    }
  }))
};

const API_URL = import.meta.env.PUBLIC_API_URL || 'http://localhost:8000';
---

<Layout title={tool.metaTitle} description={tool.metaDescription}>
  <script type="application/ld+json" set:html={JSON.stringify(jsonLd)} />
  <script type="application/ld+json" set:html={JSON.stringify(faqJsonLd)} />
  <div class="max-w-7xl mx-auto">
    <div class="mb-6">
      <h1 class="text-3xl font-bold text-gray-900 dark:text-gray-100 mb-2">ðŸ’§ Image Watermark Tool</h1>
      <p class="text-gray-600 dark:text-gray-400">Add text or image watermarks with live preview</p>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <!-- Left Panel - Settings -->
      <div class="space-y-6">
        <!-- Upload Image -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
          <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">Upload Image</h3>
          <div
            id="dropZone"
            class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-8 text-center hover:border-primary-500 transition-colors"
          >
            <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
              <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg>
            <div class="mt-4">
              <label for="fileInput" class="inline-block px-4 py-2 bg-primary-600 dark:bg-primary-500 text-white rounded-lg hover:bg-primary-700 cursor-pointer transition-colors">
                Choose Image
              </label>
              <input
                type="file"
                id="fileInput"
                accept=".jpg,.jpeg,.png,.webp,image/jpeg,image/png,image/webp"
                class="hidden"
              />
              <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">or drag and drop</p>
              <p class="text-xs text-gray-500 dark:text-gray-400 dark:text-gray-500 mt-1">JPEG, PNG, or WebP, max 10MB</p>
            </div>
          </div>

          <!-- File Info -->
          <div id="fileInfo" class="hidden mt-4 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg flex items-center justify-between">
            <div class="flex items-center space-x-3">
              <svg class="h-8 w-8 text-primary-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
              </svg>
              <div>
                <p class="text-sm font-medium text-gray-900" id="fileName"></p>
                <p class="text-xs text-gray-500" id="fileSize"></p>
              </div>
            </div>
            <button id="removeFile" class="text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:text-gray-400">
              <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>

        <!-- Watermark Settings -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
          <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">Watermark Settings</h3>

          <!-- Mode Tabs -->
          <div class="flex space-x-2 mb-6 bg-gray-100 dark:bg-gray-700 p-1 rounded-lg">
            <button id="tabText" class="flex-1 px-4 py-2 bg-white text-primary-600 dark:text-primary-400 rounded-md font-medium transition-colors">
              Text Watermark
            </button>
            <button id="tabImage" class="flex-1 px-4 py-2 text-gray-600 dark:text-gray-400 dark:text-gray-500 hover:text-gray-900 rounded-md font-medium transition-colors">
              Image Watermark
            </button>
          </div>

          <!-- Text Mode Content -->
          <div id="textMode" class="space-y-4">
            <div>
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Watermark Text</label>
              <input
                type="text"
                id="watermarkText"
                placeholder="Â© 2024 Your Name"
                class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500"
              />
            </div>

            <div>
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Font Size</label>
              <div class="flex items-center space-x-2">
                <select id="fontSizeMode" class="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg">
                  <option value="auto">Auto</option>
                  <option value="custom">Custom</option>
                </select>
                <input
                  type="number"
                  id="fontSize"
                  placeholder="40"
                  min="10"
                  max="500"
                  disabled
                  class="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg disabled:bg-gray-100"
                />
              </div>
            </div>

            <div>
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Text Color</label>
              <div class="flex items-center space-x-2">
                <input type="color" id="colorPicker" value="#ffffff" class="h-10 w-16 rounded cursor-pointer" />
                <input
                  type="text"
                  id="colorText"
                  value="#ffffff"
                  class="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg font-mono text-sm"
                />
              </div>
            </div>

            <div>
              <div class="flex items-center justify-between mb-2">
                <label class="text-sm font-medium text-gray-700">Rotation</label>
                <span class="text-sm text-gray-600 dark:text-gray-400" id="rotationValue">0Â°</span>
              </div>
              <input type="range" id="rotation" min="0" max="360" value="0" class="w-full" />
            </div>
          </div>

          <!-- Image Mode Content -->
          <div id="imageMode" class="hidden space-y-4">
            <div>
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Logo Image (PNG)</label>
              <input
                type="file"
                id="logoInput"
                accept=".png,image/png"
                class="block w-full text-sm text-gray-500 dark:text-gray-400 dark:text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-primary-50 file:text-primary-700 dark:text-primary-400 hover:file:bg-primary-100"
              />
              <p class="text-xs text-gray-500 dark:text-gray-400 dark:text-gray-500 mt-1">Upload PNG logo with transparency</p>
            </div>
            <div id="logoPreviewContainer" class="hidden">
              <p class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Logo Preview</p>
              <div class="p-4 bg-gray-50 dark:bg-gray-700 rounded-lg flex items-center space-x-3">
                <img id="logoPreview" class="h-16 w-16 object-contain" alt="Logo preview" />
                <button id="removeLogo" class="text-sm text-red-600 hover:text-red-700">Remove</button>
              </div>
            </div>
          </div>

          <!-- Common Settings -->
          <div class="mt-6 pt-6 border-t border-gray-200 dark:border-gray-700 space-y-4">
            <div>
              <div class="flex items-center justify-between mb-2">
                <label class="text-sm font-medium text-gray-700">Opacity</label>
                <span class="text-sm text-gray-600 dark:text-gray-400" id="opacityValue">30%</span>
              </div>
              <input type="range" id="opacity" min="0" max="100" value="30" class="w-full" />
            </div>

            <div>
              <div class="flex items-center justify-between mb-2">
                <label class="text-sm font-medium text-gray-700">Scale</label>
                <span class="text-sm text-gray-600 dark:text-gray-400" id="scaleValue">30%</span>
              </div>
              <input type="range" id="scale" min="10" max="100" value="30" class="w-full" />
            </div>

            <div>
              <label class="flex items-center space-x-2 cursor-pointer mb-3">
                <input type="checkbox" id="tileCheckbox" class="w-4 h-4 text-primary-600 dark:text-primary-400 border-gray-300 dark:border-gray-600 rounded focus:ring-primary-500" />
                <span class="text-sm font-medium text-gray-700">Tile across image</span>
              </label>
            </div>

            <div id="positionSection">
              <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Position</label>
              <p class="text-xs text-gray-500 dark:text-gray-400 dark:text-gray-500 mb-2">Drag watermark on preview to reposition</p>
              <input type="hidden" id="positionX" value="50" />
              <input type="hidden" id="positionY" value="50" />
            </div>

            <div id="spacingSection" class="hidden">
              <div class="flex items-center justify-between mb-2">
                <label class="text-sm font-medium text-gray-700">Spacing</label>
                <span class="text-sm text-gray-600 dark:text-gray-400" id="spacingValue">150px</span>
              </div>
              <input type="range" id="spacing" min="50" max="500" value="150" class="w-full" />
            </div>
          </div>

          <!-- Watermark Layers -->
          <div id="layersSection" class="hidden mt-6 pt-6 border-t border-gray-200 dark:border-gray-700">
            <div class="flex items-center justify-between mb-3">
              <h4 class="text-sm font-semibold text-gray-900 dark:text-gray-100">Watermark Layers</h4>
              <span class="text-xs text-gray-500" id="layerCount">0 layers</span>
            </div>
            <div id="layersList" class="space-y-2 mb-4 max-h-48 overflow-y-auto"></div>
          </div>

          <!-- Action Buttons -->
          <div class="mt-6 space-y-2">
            <button
              id="addLayerBtn"
              disabled
              class="w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            >
              + Add Watermark Layer
            </button>
            <button
              id="applyBtn"
              disabled
              class="w-full px-4 py-2 bg-primary-600 dark:bg-primary-500 text-white rounded-lg hover:bg-primary-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
            >
              Apply Watermarks
            </button>
            <button
              id="downloadBtn"
              class="hidden w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors"
            >
              Download
            </button>
          </div>
        </div>
      </div>

      <!-- Right Panel - Preview -->
      <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
        <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">Live Preview</h3>
        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg overflow-hidden" style="min-height: 400px;">
          <canvas id="previewCanvas" class="w-full h-auto"></canvas>
          <div id="previewPlaceholder" class="flex items-center justify-center h-96 text-gray-400">
            <p class="text-center">Upload an image to see preview</p>
          </div>
        </div>

        <!-- Progress -->
        <div id="progressContainer" class="hidden mt-4">
          <div class="flex items-center justify-between mb-2">
            <span class="text-sm font-medium text-gray-700">Applying watermark...</span>
            <span class="text-sm text-gray-600 dark:text-gray-400" id="progressText">0%</span>
          </div>
          <div class="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2">
            <div id="progressBar" class="bg-primary-600 h-2 rounded-full transition-all" style="width: 0%"></div>
          </div>
        </div>

        <!-- Error -->
        <div id="error" class="hidden mt-4 p-4 bg-red-50 border border-red-200 rounded-lg">
          <div class="flex">
            <svg class="h-5 w-5 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <p class="ml-3 text-sm text-red-800" id="errorMessage"></p>
          </div>
        </div>
      </div>
    </div>

    <!-- FAQ Section -->
    <FAQ items={tool.faq} />
  </div>
</Layout>

<script define:vars={{ API_URL }}>
  let selectedFile = null;
  let watermarkedBlob = null;
  let currentMode = 'text';
  let selectedLogo = null;
  let originalImage = null;

  // Watermark layers
  let watermarkLayers = [];
  let logoFiles = [];

  // Drag state
  let isDragging = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let watermarkBounds = { x: 0, y: 0, width: 0, height: 0 };

  const dropZone = document.getElementById('dropZone');
  const fileInput = document.getElementById('fileInput');
  const fileInfo = document.getElementById('fileInfo');
  const fileName = document.getElementById('fileName');
  const fileSize = document.getElementById('fileSize');
  const removeFile = document.getElementById('removeFile');

  const tabText = document.getElementById('tabText');
  const tabImage = document.getElementById('tabImage');
  const textMode = document.getElementById('textMode');
  const imageMode = document.getElementById('imageMode');

  const watermarkText = document.getElementById('watermarkText');
  const fontSizeMode = document.getElementById('fontSizeMode');
  const fontSize = document.getElementById('fontSize');
  const colorPicker = document.getElementById('colorPicker');
  const colorText = document.getElementById('colorText');
  const rotation = document.getElementById('rotation');
  const rotationValue = document.getElementById('rotationValue');

  const logoInput = document.getElementById('logoInput');
  const logoPreviewContainer = document.getElementById('logoPreviewContainer');
  const logoPreview = document.getElementById('logoPreview');
  const removeLogo = document.getElementById('removeLogo');

  const opacity = document.getElementById('opacity');
  const opacityValue = document.getElementById('opacityValue');
  const scale = document.getElementById('scale');
  const scaleValue = document.getElementById('scaleValue');
  const positionX = document.getElementById('positionX');
  const positionY = document.getElementById('positionY');
  const tileCheckbox = document.getElementById('tileCheckbox');
  const spacing = document.getElementById('spacing');
  const spacingValue = document.getElementById('spacingValue');
  const positionSection = document.getElementById('positionSection');
  const spacingSection = document.getElementById('spacingSection');

  const addLayerBtn = document.getElementById('addLayerBtn');
  const layersSection = document.getElementById('layersSection');
  const layersList = document.getElementById('layersList');
  const layerCount = document.getElementById('layerCount');
  const applyBtn = document.getElementById('applyBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const progressContainer = document.getElementById('progressContainer');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const error = document.getElementById('error');
  const errorMessage = document.getElementById('errorMessage');

  const previewCanvas = document.getElementById('previewCanvas');
  const previewPlaceholder = document.getElementById('previewPlaceholder');
  const ctx = previewCanvas.getContext('2d');

  // Mode switching
  if (tabText) {
    tabText.addEventListener('click', function() {
      currentMode = 'text';
      tabText.classList.add('bg-white', 'text-primary-600');
      tabText.classList.remove('text-gray-600');
      tabImage.classList.remove('bg-white', 'text-primary-600');
      tabImage.classList.add('text-gray-600');
      if (textMode) textMode.classList.remove('hidden');
      if (imageMode) imageMode.classList.add('hidden');
      updatePreview();
    });
  }

  if (tabImage) {
    tabImage.addEventListener('click', function() {
      currentMode = 'image';
      tabImage.classList.add('bg-white', 'text-primary-600');
      tabImage.classList.remove('text-gray-600');
      tabText.classList.remove('bg-white', 'text-primary-600');
      tabText.classList.add('text-gray-600');
      if (imageMode) imageMode.classList.remove('hidden');
      if (textMode) textMode.classList.add('hidden');
      updatePreview();
    });
  }

  // File upload handlers
  if (fileInput) {
    fileInput.addEventListener('change', function(e) {
      if (e.target.files && e.target.files.length > 0) {
        handleFile(e.target.files[0]);
      }
    });
  }

  if (dropZone) {
    dropZone.addEventListener('dragover', function(e) {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.add('border-primary-500', 'bg-primary-50');
    });

    dropZone.addEventListener('dragleave', function(e) {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('border-primary-500', 'bg-primary-50');
    });

    dropZone.addEventListener('drop', function(e) {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove('border-primary-500', 'bg-primary-50');
      if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
        handleFile(e.dataTransfer.files[0]);
      }
    });
  }

  if (removeFile) {
    removeFile.addEventListener('click', function() {
      resetUpload();
    });
  }

  function handleFile(file) {
    hideError();

    if (!file || !file.type.match(/image\/(jpeg|png|webp)/)) {
      showError('Please upload a JPEG, PNG, or WebP file');
      return;
    }

    if (file.size > 10 * 1024 * 1024) {
      showError('File size must be less than 10MB');
      return;
    }

    selectedFile = file;
    if (fileName) fileName.textContent = file.name;
    if (fileSize) fileSize.textContent = formatBytes(file.size);

    if (dropZone) dropZone.style.display = 'none';
    if (fileInfo) fileInfo.classList.remove('hidden');
    if (addLayerBtn) addLayerBtn.disabled = false;

    // Load image for preview
    const reader = new FileReader();
    reader.onload = function(e) {
      const img = new Image();
      img.onload = function() {
        originalImage = img;
        updatePreview();
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }

  function resetUpload() {
    selectedFile = null;
    watermarkedBlob = null;
    originalImage = null;
    watermarkLayers = [];
    logoFiles = [];
    if (fileInput) fileInput.value = '';
    if (dropZone) dropZone.style.display = 'block';
    if (fileInfo) fileInfo.classList.add('hidden');
    if (addLayerBtn) addLayerBtn.disabled = true;
    if (applyBtn) applyBtn.disabled = true;
    if (downloadBtn) downloadBtn.classList.add('hidden');
    if (progressContainer) progressContainer.classList.add('hidden');
    if (previewCanvas) previewCanvas.style.display = 'none';
    if (previewPlaceholder) previewPlaceholder.classList.remove('hidden');
    renderLayers();
    hideError();
  }

  // Logo upload
  if (logoInput) {
    logoInput.addEventListener('change', function(e) {
      if (e.target.files && e.target.files.length > 0) {
        const file = e.target.files[0];
        if (!file.type.includes('png')) {
          showError('Logo must be a PNG file');
          return;
        }
        selectedLogo = file;
        const reader = new FileReader();
        reader.onload = function(e) {
          if (logoPreview) logoPreview.src = e.target.result;
          if (logoPreviewContainer) logoPreviewContainer.classList.remove('hidden');
          updatePreview();
        };
        reader.readAsDataURL(file);
      }
    });
  }

  if (removeLogo) {
    removeLogo.addEventListener('click', function() {
      selectedLogo = null;
      if (logoInput) logoInput.value = '';
      if (logoPreviewContainer) logoPreviewContainer.classList.add('hidden');
      updatePreview();
    });
  }

  // Settings change handlers
  if (opacity) {
    opacity.addEventListener('input', function() {
      if (opacityValue) opacityValue.textContent = opacity.value + '%';
      updatePreview();
    });
  }

  if (scale) {
    scale.addEventListener('input', function() {
      if (scaleValue) scaleValue.textContent = scale.value + '%';
      updatePreview();
    });
  }

  if (watermarkText) {
    watermarkText.addEventListener('input', updatePreview);
  }

  if (fontSizeMode) {
    fontSizeMode.addEventListener('change', function() {
      if (fontSize) fontSize.disabled = fontSizeMode.value === 'auto';
      updatePreview();
    });
  }

  if (fontSize) {
    fontSize.addEventListener('input', updatePreview);
  }

  if (colorPicker) {
    colorPicker.addEventListener('input', function() {
      if (colorText) colorText.value = colorPicker.value;
      updatePreview();
    });
  }

  if (colorText) {
    colorText.addEventListener('input', function() {
      if (colorPicker && /^#[0-9A-Fa-f]{6}$/.test(colorText.value)) {
        colorPicker.value = colorText.value;
      }
      updatePreview();
    });
  }

  if (rotation) {
    rotation.addEventListener('input', function() {
      if (rotationValue) rotationValue.textContent = rotation.value + 'Â°';
      updatePreview();
    });
  }

  if (tileCheckbox) {
    tileCheckbox.addEventListener('change', function() {
      if (tileCheckbox.checked) {
        if (positionSection) positionSection.classList.add('hidden');
        if (spacingSection) spacingSection.classList.remove('hidden');
      } else {
        if (positionSection) positionSection.classList.remove('hidden');
        if (spacingSection) spacingSection.classList.add('hidden');
      }
      updatePreview();
    });
  }

  if (spacing) {
    spacing.addEventListener('input', function() {
      if (spacingValue) spacingValue.textContent = spacing.value + 'px';
      updatePreview();
    });
  }

  // Add Layer button
  if (addLayerBtn) {
    addLayerBtn.addEventListener('click', function() {
      const layer = {
        type: currentMode,
        text: currentMode === 'text' ? (watermarkText ? watermarkText.value : '') : '',
        opacity: opacity ? parseInt(opacity.value) : 30,
        position_x: positionX ? parseFloat(positionX.value) : 50,
        position_y: positionY ? parseFloat(positionY.value) : 50,
        scale: scale ? parseInt(scale.value) : 30,
        color: colorText ? colorText.value : '#ffffff',
        font_size: fontSizeMode && fontSizeMode.value === 'auto' ? 'auto' : (fontSize ? fontSize.value : '40'),
        rotation: rotation ? parseInt(rotation.value) : 0,
        tile: tileCheckbox ? tileCheckbox.checked : false,
        spacing: spacing ? parseInt(spacing.value) : 150,
        logoFile: currentMode === 'image' ? selectedLogo : null,
        logoIndex: currentMode === 'image' && selectedLogo ? logoFiles.length : -1
      };

      if (currentMode === 'image' && selectedLogo) {
        logoFiles.push(selectedLogo);
      }

      watermarkLayers.push(layer);
      renderLayers();
      updatePreview();
    });
  }

  function renderLayers() {
    if (!layersList || !layerCount || !layersSection) return;

    if (watermarkLayers.length === 0) {
      layersSection.classList.add('hidden');
      layerCount.textContent = '0 layers';
      if (applyBtn) applyBtn.disabled = true;
      return;
    }

    layersSection.classList.remove('hidden');
    layerCount.textContent = watermarkLayers.length + ' layer' + (watermarkLayers.length > 1 ? 's' : '');
    if (applyBtn) applyBtn.disabled = false;

    layersList.innerHTML = watermarkLayers.map(function(layer, index) {
      const label = layer.type === 'text' ?
        (layer.text.substring(0, 20) + (layer.text.length > 20 ? '...' : '')) :
        'Logo ' + (index + 1);
      const pos = layer.tile ? 'Tiled' : Math.round(layer.position_x) + '%, ' + Math.round(layer.position_y) + '%';

      return '<div class="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-700 rounded border border-gray-200 dark:border-gray-700">' +
        '<div class="flex-1">' +
          '<p class="text-sm font-medium text-gray-900 dark:text-gray-100">' + label + '</p>' +
          '<p class="text-xs text-gray-500">Position: ' + pos + ' | Opacity: ' + layer.opacity + '%</p>' +
        '</div>' +
        '<button class="ml-2 text-red-600 hover:text-red-700 font-bold text-lg" data-index="' + index + '">Ã—</button>' +
      '</div>';
    }).join('');

    // Add delete handlers
    layersList.querySelectorAll('button').forEach(function(btn) {
      btn.addEventListener('click', function() {
        const index = parseInt(btn.dataset.index);
        if (watermarkLayers[index].type === 'image' && watermarkLayers[index].logoIndex >= 0) {
          logoFiles.splice(watermarkLayers[index].logoIndex, 1);
          // Update logo indices
          watermarkLayers.forEach(function(l) {
            if (l.logoIndex > watermarkLayers[index].logoIndex) l.logoIndex--;
          });
        }
        watermarkLayers.splice(index, 1);
        renderLayers();
        updatePreview();
      });
    });
  }


  // Canvas drag & drop handlers
  if (previewCanvas) {
    // Mouse events
    previewCanvas.addEventListener('mousedown', handleDragStart);
    previewCanvas.addEventListener('mousemove', handleDragMove);
    previewCanvas.addEventListener('mouseup', handleDragEnd);
    previewCanvas.addEventListener('mouseleave', handleDragEnd);

    // Touch events
    previewCanvas.addEventListener('touchstart', handleTouchStart);
    previewCanvas.addEventListener('touchmove', handleTouchMove);
    previewCanvas.addEventListener('touchend', handleDragEnd);

    // Prevent default touch behavior
    previewCanvas.style.touchAction = 'none';
  }

  function handleDragStart(e) {
    if (!originalImage) return;

    const rect = previewCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Check if click is inside watermark bounds
    if (
      x >= watermarkBounds.x &&
      x <= watermarkBounds.x + watermarkBounds.width &&
      y >= watermarkBounds.y &&
      y <= watermarkBounds.y + watermarkBounds.height
    ) {
      isDragging = true;
      dragOffsetX = x - watermarkBounds.x - watermarkBounds.width / 2;
      dragOffsetY = y - watermarkBounds.y - watermarkBounds.height / 2;
      previewCanvas.style.cursor = 'grabbing';
    }
  }

  function handleTouchStart(e) {
    if (!originalImage || e.touches.length === 0) return;
    e.preventDefault();

    const rect = previewCanvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    // Check if touch is inside watermark bounds
    if (
      x >= watermarkBounds.x &&
      x <= watermarkBounds.x + watermarkBounds.width &&
      y >= watermarkBounds.y &&
      y <= watermarkBounds.y + watermarkBounds.height
    ) {
      isDragging = true;
      dragOffsetX = x - watermarkBounds.x - watermarkBounds.width / 2;
      dragOffsetY = y - watermarkBounds.y - watermarkBounds.height / 2;
    }
  }

  function handleDragMove(e) {
    if (!isDragging || !originalImage) return;

    const rect = previewCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    updateWatermarkPosition(x, y);
  }

  function handleTouchMove(e) {
    if (!isDragging || !originalImage || e.touches.length === 0) return;
    e.preventDefault();

    const rect = previewCanvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    updateWatermarkPosition(x, y);
  }

  function handleDragEnd() {
    if (isDragging) {
      isDragging = false;
      previewCanvas.style.cursor = 'default';
    }
  }

  function updateWatermarkPosition(canvasX, canvasY) {
    const canvasWidth = previewCanvas.width;
    const canvasHeight = previewCanvas.height;

    // Calculate new position (subtract offset)
    const centerX = canvasX - dragOffsetX;
    const centerY = canvasY - dragOffsetY;

    // Convert to percentages
    let newPosX = (centerX / canvasWidth) * 100;
    let newPosY = (centerY / canvasHeight) * 100;

    // Clamp to 0-100
    newPosX = Math.max(0, Math.min(100, newPosX));
    newPosY = Math.max(0, Math.min(100, newPosY));

    // Update hidden inputs
    if (positionX) positionX.value = newPosX.toFixed(1);
    if (positionY) positionY.value = newPosY.toFixed(1);

    // Redraw preview
    updatePreview();
  }

  // Render single layer on canvas
  function renderLayer(layer, canvasWidth, canvasHeight, canvasScale) {
    const opacityVal = layer.opacity / 100;
    const scaleVal = layer.scale;
    const posX = layer.position_x;
    const posY = layer.position_y;
    const rotationVal = layer.rotation || 0;
    const isTiled = layer.tile || false;
    const spacingVal = layer.spacing || 150;

    if (layer.type === 'text') {
      const text = layer.text;
      if (!text) return;

      let fontSizeVal = 40;
      if (layer.font_size === 'auto') {
        fontSizeVal = Math.floor(Math.min(canvasWidth, canvasHeight) * 0.05);
        fontSizeVal = Math.max(20, Math.min(fontSizeVal, 100));
      } else {
        fontSizeVal = parseInt(layer.font_size) * canvasScale;
      }

      ctx.font = fontSizeVal + 'px Arial';
      ctx.fillStyle = layer.color || '#ffffff';
      ctx.globalAlpha = opacityVal;

      const metrics = ctx.measureText(text);
      const textWidth = metrics.width;
      const textHeight = fontSizeVal;

      if (isTiled) {
        const spacingScaled = spacingVal * canvasScale;
        for (let y = 0; y < canvasHeight + spacingScaled; y += spacingScaled) {
          for (let x = 0; x < canvasWidth + spacingScaled; x += spacingScaled) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotationVal * Math.PI / 180);
            ctx.fillText(text, -textWidth / 2, textHeight / 2);
            ctx.restore();
          }
        }
      } else {
        const centerX = canvasWidth * posX / 100;
        const centerY = canvasHeight * posY / 100;

        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(rotationVal * Math.PI / 180);
        ctx.fillText(text, -textWidth / 2, textHeight / 2);
        ctx.restore();
      }

      ctx.globalAlpha = 1;
    } else if (layer.type === 'image' && layer.logoFile) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const logoImg = new Image();
        logoImg.onload = function() {
          const logoTargetWidth = canvasWidth * scaleVal / 100;
          const aspectRatio = logoImg.height / logoImg.width;
          const logoWidth = logoTargetWidth;
          const logoHeight = logoTargetWidth * aspectRatio;

          ctx.globalAlpha = opacityVal;

          if (isTiled) {
            const spacingScaled = spacingVal * canvasScale;
            for (let y = 0; y < canvasHeight + spacingScaled; y += spacingScaled) {
              for (let x = 0; x < canvasWidth + spacingScaled; x += spacingScaled) {
                ctx.drawImage(logoImg, x - logoWidth / 2, y - logoHeight / 2, logoWidth, logoHeight);
              }
            }
          } else {
            const x = (canvasWidth * posX / 100) - (logoWidth / 2);
            const y = (canvasHeight * posY / 100) - (logoHeight / 2);
            ctx.drawImage(logoImg, x, y, logoWidth, logoHeight);
          }

          ctx.globalAlpha = 1;
        };
        logoImg.src = e.target.result;
      };
      reader.readAsDataURL(layer.logoFile);
    }
  }

  // Preview update function
  function updatePreview() {
    if (!originalImage) return;

    const maxWidth = 800;
    const canvasScale = Math.min(1, maxWidth / originalImage.width);
    const canvasWidth = originalImage.width * canvasScale;
    const canvasHeight = originalImage.height * canvasScale;

    previewCanvas.width = canvasWidth;
    previewCanvas.height = canvasHeight;
    if (previewCanvas) previewCanvas.style.display = 'block';
    if (previewPlaceholder) previewPlaceholder.classList.add('hidden');

    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    ctx.drawImage(originalImage, 0, 0, canvasWidth, canvasHeight);

    // Render all saved layers first
    watermarkLayers.forEach(function(layer) {
      renderLayer(layer, canvasWidth, canvasHeight, canvasScale);
    });

    // Then render current editing watermark
    const opacityVal = opacity ? parseInt(opacity.value) / 100 : 0.3;
    const scaleVal = scale ? parseInt(scale.value) : 30;
    const posX = positionX ? parseFloat(positionX.value) : 50;
    const posY = positionY ? parseFloat(positionY.value) : 50;
    const rotationVal = rotation ? parseInt(rotation.value) : 0;
    const isTiled = tileCheckbox ? tileCheckbox.checked : false;
    const spacingVal = spacing ? parseInt(spacing.value) : 150;

    if (currentMode === 'text') {
      const text = watermarkText ? watermarkText.value : '';
      if (!text) return;

      let fontSizeVal = 40;
      if (fontSizeMode && fontSizeMode.value === 'auto') {
        fontSizeVal = Math.floor(Math.min(canvasWidth, canvasHeight) * 0.05);
        fontSizeVal = Math.max(20, Math.min(fontSizeVal, 100));
      } else if (fontSize && fontSize.value) {
        fontSizeVal = parseInt(fontSize.value) * canvasScale;
      }

      ctx.font = fontSizeVal + 'px Arial';
      ctx.fillStyle = colorText ? colorText.value : '#ffffff';
      ctx.globalAlpha = opacityVal;

      const metrics = ctx.measureText(text);
      const textWidth = metrics.width;
      const textHeight = fontSizeVal;

      if (isTiled) {
        // Tiled mode: repeat watermark across entire image
        const spacingScaled = spacingVal * canvasScale;
        for (let y = 0; y < canvasHeight + spacingScaled; y += spacingScaled) {
          for (let x = 0; x < canvasWidth + spacingScaled; x += spacingScaled) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotationVal * Math.PI / 180);
            ctx.fillText(text, -textWidth / 2, textHeight / 2);
            ctx.restore();
          }
        }
        // No bounds for tiling mode (drag disabled)
        watermarkBounds = { x: 0, y: 0, width: 0, height: 0 };
      } else {
        // Single watermark mode
        const centerX = canvasWidth * posX / 100;
        const centerY = canvasHeight * posY / 100;

        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(rotationVal * Math.PI / 180);
        ctx.fillText(text, -textWidth / 2, textHeight / 2);
        ctx.restore();

        // Store bounds for drag detection (approximate, without rotation)
        watermarkBounds = {
          x: centerX - textWidth / 2,
          y: centerY - textHeight / 2,
          width: textWidth,
          height: textHeight
        };
      }

      ctx.globalAlpha = 1;
    } else if (currentMode === 'image' && selectedLogo && logoPreview) {
      const logoImg = new Image();
      logoImg.onload = function() {
        // Calculate logo size based on scale percentage of canvas width
        const logoTargetWidth = canvasWidth * scaleVal / 100;
        const aspectRatio = logoImg.height / logoImg.width;
        const logoWidth = logoTargetWidth;
        const logoHeight = logoTargetWidth * aspectRatio;

        ctx.globalAlpha = opacityVal;

        if (isTiled) {
          // Tiled mode: repeat logo across entire image
          const spacingScaled = spacingVal * canvasScale;
          for (let y = 0; y < canvasHeight + spacingScaled; y += spacingScaled) {
            for (let x = 0; x < canvasWidth + spacingScaled; x += spacingScaled) {
              ctx.drawImage(logoImg, x - logoWidth / 2, y - logoHeight / 2, logoWidth, logoHeight);
            }
          }
          // No bounds for tiling mode (drag disabled)
          watermarkBounds = { x: 0, y: 0, width: 0, height: 0 };
        } else {
          // Single watermark mode
          const x = (canvasWidth * posX / 100) - (logoWidth / 2);
          const y = (canvasHeight * posY / 100) - (logoHeight / 2);

          ctx.drawImage(logoImg, x, y, logoWidth, logoHeight);

          // Store bounds for drag detection
          watermarkBounds = {
            x: x,
            y: y,
            width: logoWidth,
            height: logoHeight
          };
        }

        ctx.globalAlpha = 1;
      };
      logoImg.src = logoPreview.src;
    }
  }

  // Apply watermark
  if (applyBtn) {
    applyBtn.addEventListener('click', async function() {
      if (!selectedFile) {
        showError('Please select an image first');
        return;
      }

      if (watermarkLayers.length === 0) {
        showError('Please add at least one watermark layer');
        return;
      }

      hideError();
      if (progressContainer) progressContainer.classList.remove('hidden');
      applyBtn.disabled = true;
      if (downloadBtn) downloadBtn.classList.add('hidden');

      try {
        const formData = new FormData();
        formData.append('file', selectedFile);

        // Prepare watermarks JSON
        const watermarksData = watermarkLayers.map(function(layer) {
          return {
            type: layer.type,
            text: layer.text || '',
            opacity: layer.opacity,
            position_x: layer.position_x,
            position_y: layer.position_y,
            scale: layer.scale,
            color: layer.color || '#ffffff',
            font_size: layer.font_size,
            rotation: layer.rotation || 0,
            tile: layer.tile || false,
            spacing: layer.spacing || 150,
            logoIndex: layer.logoIndex
          };
        });

        formData.append('watermarks_json', JSON.stringify(watermarksData));

        // Append logo files
        logoFiles.forEach(function(logoFile, index) {
          formData.append('logo_' + index, logoFile);
        });

        const response = await fetch(API_URL + '/watermark', {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) {
          const errorData = await response.json().catch(function() { return {}; });
          throw new Error(errorData.detail || 'Server error: ' + response.status);
        }

        watermarkedBlob = await response.blob();

        if (progressBar) progressBar.style.width = '100%';
        if (progressText) progressText.textContent = '100%';

        setTimeout(function() {
          if (progressContainer) progressContainer.classList.add('hidden');
          if (downloadBtn) downloadBtn.classList.remove('hidden');
        }, 500);

      } catch (err) {
        showError(err.message || 'Failed to apply watermark. Please check your connection and try again.');
        applyBtn.disabled = false;
        if (progressContainer) progressContainer.classList.add('hidden');
      }
    });
  }

  // Download
  if (downloadBtn) {
    downloadBtn.addEventListener('click', function() {
      if (!watermarkedBlob || !selectedFile) return;

      const url = URL.createObjectURL(watermarkedBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = selectedFile.name.replace(/\.(jpg|jpeg|png|webp)$/i, '_watermarked.$1');
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });
  }

  function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
  }

  function showError(message) {
    if (errorMessage) errorMessage.textContent = message;
    if (error) error.classList.remove('hidden');
  }

  function hideError() {
    if (error) error.classList.add('hidden');
  }
</script>
